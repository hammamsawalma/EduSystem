const mongoose = require('mongoose');

const financialReportSchema = new mongoose.Schema({
  reportDate: {
    type: Date,
    required: [true, 'Report date is required'],
    index: true
  },
  reportType: {
    type: String,
    enum: ['daily', 'weekly', 'monthly', 'quarterly', 'yearly', 'custom'],
    required: [true, 'Report type is required'],
    index: true
  },
  periodStart: {
    type: Date,
    required: [true, 'Period start date is required']
  },
  periodEnd: {
    type: Date,
    required: [true, 'Period end date is required']
  },
  revenue: {
    studentPayments: {
      total: {
        type: Number,
        default: 0
      },
      received: {
        type: Number,
        default: 0
      },
      pending: {
        type: Number,
        default: 0
      },
      overdue: {
        type: Number,
        default: 0
      }
    },
    otherIncome: {
      type: Number,
      default: 0
    },
    totalRevenue: {
      type: Number,
      default: 0
    }
  },
  expenses: {
    teacherPayments: {
      total: {
        type: Number,
        default: 0
      },
      paid: {
        type: Number,
        default: 0
      },
      pending: {
        type: Number,
        default: 0
      }
    },
    generalExpenses: {
      rent: {
        type: Number,
        default: 0
      },
      utilities: {
        type: Number,
        default: 0
      },
      supplies: {
        type: Number,
        default: 0
      },
      marketing: {
        type: Number,
        default: 0
      },
      maintenance: {
        type: Number,
        default: 0
      },
      insurance: {
        type: Number,
        default: 0
      },
      other: {
        type: Number,
        default: 0
      },
      total: {
        type: Number,
        default: 0
      }
    },
    totalExpenses: {
      type: Number,
      default: 0
    }
  },
  netIncome: {
    type: Number,
    default: 0
  },
  profitMargin: {
    type: Number,
    default: 0
  },
  studentMetrics: {
    totalStudents: {
      type: Number,
      default: 0
    },
    activeStudents: {
      type: Number,
      default: 0
    },
    newStudents: {
      type: Number,
      default: 0
    },
    revenuePerStudent: {
      type: Number,
      default: 0
    }
  },
  teacherMetrics: {
    totalTeachers: {
      type: Number,
      default: 0
    },
    activeTeachers: {
      type: Number,
      default: 0
    },
    totalHoursWorked: {
      type: Number,
      default: 0
    },
    averageHourlyRate: {
      type: Number,
      default: 0
    }
  },
  generatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Generated by is required']
  },
  isArchived: {
    type: Boolean,
    default: false
  }
}, {
  timestamps: true
});

// Indexes for performance
financialReportSchema.index({ reportType: 1, reportDate: -1 });
financialReportSchema.index({ periodStart: 1, periodEnd: 1 });
financialReportSchema.index({ isArchived: 1, reportDate: -1 });

// Virtual for profit/loss status
financialReportSchema.virtual('profitLossStatus').get(function() {
  if (this.netIncome > 0) return 'profit';
  if (this.netIncome < 0) return 'loss';
  return 'breakeven';
});

// Virtual for formatted net income
financialReportSchema.virtual('formattedNetIncome').get(function() {
  const sign = this.netIncome >= 0 ? '' : '-';
  return `${sign}$${Math.abs(this.netIncome).toFixed(2)}`;
});

// Pre-save middleware to calculate totals
financialReportSchema.pre('save', function(next) {
  // Calculate total revenue
  this.revenue.totalRevenue = 
    this.revenue.studentPayments.total + 
    this.revenue.otherIncome;
  
  // Calculate total general expenses
  this.expenses.generalExpenses.total = 
    this.expenses.generalExpenses.rent +
    this.expenses.generalExpenses.utilities +
    this.expenses.generalExpenses.supplies +
    this.expenses.generalExpenses.marketing +
    this.expenses.generalExpenses.maintenance +
    this.expenses.generalExpenses.insurance +
    this.expenses.generalExpenses.other;
  
  // Calculate total expenses
  this.expenses.totalExpenses = 
    this.expenses.teacherPayments.total + 
    this.expenses.generalExpenses.total;
  
  // Calculate net income
  this.netIncome = this.revenue.totalRevenue - this.expenses.totalExpenses;
  
  // Calculate profit margin
  if (this.revenue.totalRevenue > 0) {
    this.profitMargin = (this.netIncome / this.revenue.totalRevenue) * 100;
  } else {
    this.profitMargin = 0;
  }
  
  // Calculate revenue per student
  if (this.studentMetrics.activeStudents > 0) {
    this.studentMetrics.revenuePerStudent = 
      this.revenue.studentPayments.received / this.studentMetrics.activeStudents;
  }
  
  next();
});

// Static method to generate financial report
financialReportSchema.statics.generateReport = async function(startDate, endDate, generatedBy, reportType = 'custom') {
  const Payment = require('./Payment');
  const TeacherPayment = require('./TeacherPayment');
  const Expense = require('./Expense');
  const Student = require('./Student');
  const User = require('./User');
  const TimeEntry = require('./TimeEntry');
  
  try {
    // Get student payments data
    const studentPaymentsData = await Payment.aggregate([
      {
        $match: {
          paymentDate: { $gte: startDate, $lte: endDate }
        }
      },
      {
        $group: {
          _id: '$status',
          total: { $sum: '$amount' },
          count: { $sum: 1 }
        }
      }
    ]);
    
    let studentPayments = {
      total: 0,
      received: 0,
      pending: 0,
      overdue: 0
    };
    
    studentPaymentsData.forEach(item => {
      studentPayments.total += item.total;
      if (item._id === 'completed') {
        studentPayments.received = item.total;
      } else if (item._id === 'pending') {
        studentPayments.pending = item.total;
      }
    });
    
    // Get overdue student payments
    const overduePayments = await Payment.aggregate([
      {
        $match: {
          status: 'pending',
          dueDate: { $lt: new Date() },
          paymentDate: { $gte: startDate, $lte: endDate }
        }
      },
      {
        $group: {
          _id: null,
          total: { $sum: '$amount' }
        }
      }
    ]);
    
    if (overduePayments.length > 0) {
      studentPayments.overdue = overduePayments[0].total;
    }
    
    // Get teacher payments data
    const teacherPaymentsData = await TeacherPayment.aggregate([
      {
        $match: {
          paymentDate: { $gte: startDate, $lte: endDate }
        }
      },
      {
        $group: {
          _id: '$status',
          total: { $sum: '$amount' },
          count: { $sum: 1 }
        }
      }
    ]);
    
    let teacherPayments = {
      total: 0,
      paid: 0,
      pending: 0
    };
    
    teacherPaymentsData.forEach(item => {
      teacherPayments.total += item.total;
      if (item._id === 'paid') {
        teacherPayments.paid = item.total;
      } else if (['pending', 'approved'].includes(item._id)) {
        teacherPayments.pending += item.total;
      }
    });
    
    // Get general expenses data
    const generalExpensesData = await Expense.aggregate([
      {
        $match: {
          date: { $gte: startDate, $lte: endDate },
          status: 'approved'
        }
      },
      {
        $group: {
          _id: '$category',
          total: { $sum: '$amount' }
        }
      }
    ]);
    
    let generalExpenses = {
      rent: 0,
      utilities: 0,
      supplies: 0,
      marketing: 0,
      maintenance: 0,
      insurance: 0,
      other: 0,
      total: 0
    };
    
    generalExpensesData.forEach(item => {
      const category = item._id.toLowerCase();
      if (generalExpenses.hasOwnProperty(category)) {
        generalExpenses[category] = item.total;
      } else {
        generalExpenses.other += item.total;
      }
      generalExpenses.total += item.total;
    });
    
    // Get student metrics
    const studentMetrics = await Student.aggregate([
      {
        $facet: {
          total: [
            { $count: 'count' }
          ],
          active: [
            { $match: { status: 'active' } },
            { $count: 'count' }
          ],
          new: [
            { 
              $match: { 
                enrollmentDate: { $gte: startDate, $lte: endDate }
              } 
            },
            { $count: 'count' }
          ]
        }
      }
    ]);
    
    const studentMetricsResult = {
      totalStudents: studentMetrics[0].total[0]?.count || 0,
      activeStudents: studentMetrics[0].active[0]?.count || 0,
      newStudents: studentMetrics[0].new[0]?.count || 0,
      revenuePerStudent: 0
    };
    
    // Get teacher metrics
    const teacherMetrics = await User.aggregate([
      {
        $match: { role: 'teacher' }
      },
      {
        $facet: {
          total: [
            { $count: 'count' }
          ],
          active: [
            { $match: { status: 'approved' } },
            { $count: 'count' }
          ]
        }
      }
    ]);
    
    // Get hours worked and average rate
    const hoursData = await TimeEntry.aggregate([
      {
        $match: {
          date: { $gte: startDate, $lte: endDate }
        }
      },
      {
        $group: {
          _id: null,
          totalHours: { $sum: '$hoursWorked' },
          avgRate: { $avg: '$hourlyRate' }
        }
      }
    ]);
    
    const teacherMetricsResult = {
      totalTeachers: teacherMetrics[0].total[0]?.count || 0,
      activeTeachers: teacherMetrics[0].active[0]?.count || 0,
      totalHoursWorked: hoursData[0]?.totalHours || 0,
      averageHourlyRate: hoursData[0]?.avgRate || 0
    };
    
    // Create the report
    const report = new this({
      reportDate: new Date(),
      reportType,
      periodStart: startDate,
      periodEnd: endDate,
      revenue: {
        studentPayments,
        otherIncome: 0, // Can be expanded later
        totalRevenue: 0 // Will be calculated in pre-save
      },
      expenses: {
        teacherPayments,
        generalExpenses,
        totalExpenses: 0 // Will be calculated in pre-save
      },
      netIncome: 0, // Will be calculated in pre-save
      profitMargin: 0, // Will be calculated in pre-save
      studentMetrics: studentMetricsResult,
      teacherMetrics: teacherMetricsResult,
      generatedBy
    });
    
    await report.save();
    return report;
    
  } catch (error) {
    throw new Error(`Failed to generate financial report: ${error.message}`);
  }
};

// Static method to get comparison report
financialReportSchema.statics.getComparison = async function(currentStart, currentEnd, previousStart, previousEnd) {
  const currentReport = await this.generateReport(currentStart, currentEnd, null, 'comparison');
  const previousReport = await this.generateReport(previousStart, previousEnd, null, 'comparison');
  
  return {
    current: currentReport,
    previous: previousReport,
    changes: {
      revenue: {
        amount: currentReport.revenue.totalRevenue - previousReport.revenue.totalRevenue,
        percentage: previousReport.revenue.totalRevenue > 0 
          ? ((currentReport.revenue.totalRevenue - previousReport.revenue.totalRevenue) / previousReport.revenue.totalRevenue) * 100 
          : 0
      },
      expenses: {
        amount: currentReport.expenses.totalExpenses - previousReport.expenses.totalExpenses,
        percentage: previousReport.expenses.totalExpenses > 0 
          ? ((currentReport.expenses.totalExpenses - previousReport.expenses.totalExpenses) / previousReport.expenses.totalExpenses) * 100 
          : 0
      },
      netIncome: {
        amount: currentReport.netIncome - previousReport.netIncome,
        percentage: previousReport.netIncome !== 0 
          ? ((currentReport.netIncome - previousReport.netIncome) / Math.abs(previousReport.netIncome)) * 100 
          : 0
      }
    }
  };
};

// Ensure virtual fields are serialized
financialReportSchema.set('toJSON', {
  virtuals: true,
  transform: function(doc, ret) {
    delete ret.__v;
    return ret;
  }
});

module.exports = mongoose.model('FinancialReport', financialReportSchema);
